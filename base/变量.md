简单变量及声明

## 01 使用变量要声明
Go 语言中，使用变量要提前声明，每一个声明有一个通用的形式：

```go
var name type = expression
```

其中，type（类型）和 expression（表达式）可以省略一个，但是不能都省略。

如果省略类型，那么类型将由初始化表达式自动推导，比如：

```go
var a = 1       // 整形
var f = 1.2     // 浮点型
var s = "hello" // 字符串型
```

如果省略表达式，那么初始值将会被初始化为对应类型的零值。


## 02 零值机制
Go 语言规定以下每种类型对应不同的零值：


- 数字是 `0`
- 布尔值是 `false`
- 字符串是 `""`
- 接口和引用类型（slice、指针、map、通道、函数）是 `nil`
- 数组和结构体这样的复合类型，是其所有成员的零值，比如：

```go
type tree struct {
    value int
    left, right *tree
}
func main() {
    var t tree
    fmt.Printf("%v\n", t)
}
```

输出：

```
{0 <nil> <nil>}
```

这个就是 Go 语言的 **零值机制** 。它能保障程序具有良好的定义，不会像 C/C++ 等语言一样，出现未初始化的变量就造成程序的崩溃或一些不可预料的行为，减轻了程序员的负担。

## 03 变量列表
Go 语言中变量也可以以列表的形式声明，比如：

自动初始化零值：

```go
var i, j, k int
```

指定初始化值：

```go
var i, b, f, s = 1, true, 2.3, "string" // int, bool, float64, string
```

通过函数返回值初始化：

```go
var f, err = os.Open(name) // os.Open 返回一个文件和一个错误
```

这里我们可以看到函数可以返回多个值，具体我们留到后面函数章节再进行讲解。

通过括号列表初始化：

```go
var (
    a int
    s string
)
```

这种写法通常出现在包级别变量中，包级别变量的概念见下面「变量的生命周期」小节。

## 04 短变量

为了书写方便，Go 语言中使用 「短变量」来声明和初始化局部变量，注意， **只能是局部变量** 。

形式是：

```
name := expression
```

比如：

```go
i := 1
f := 2.3
```

用 `:=` 省略了 `var` 关键字。

同样也可以声明多个变量：

```go
i, j := 0, 1
f, err := os.Open(name)
```

但要注意，短变量声明至少要声明一个变量，比如：

```go
// 1
i, j := 0, 1
i, k := 0, 2

// 2
i, err := 0, 1
i, err := 0, 2
```

第 1 种情况，第一条语句声明了 i, j，但第二条语句仅声明了 k，而对 i 赋值；

而第 2 种情况，两条语句都是同样的声明，代码就无法编译通过。

那什么情况该用 `var` 呢？通常有以下几种情况的，考虑用 `var` 声明变量。

- 跟初始化表达式类型不一致的局部变量

```go
i := 100 //使用 :=
var f float64 = 100 // 使用 var
```

- 后面才需要对变量赋值，以及变量的初始值不重要

```go
var name []string
var err error
```



## 05 变量的赋值

特别注意短变量和变量的赋值的陷阱，已经声明过的变量不能再用 `:=`，只能赋值 `=`。

赋值用来更新变量，可以是普通的赋值：

```go
i := 1
i = 2
```

也可以结合算术操作符：

```go
arr[i] *= val
```

数字变量也可以用 `++`、`--` 实现自增自减。

```go
i := 1
i ++
i --
```

>  注意：Go 语言没有前置 `++i`、`--i` 这种写法。而且不能赋值，如 `j=i++`，因为在 Go 中，形如 `i++,i--` 不是表达式，而是语句，因此不能赋值给另外的变量。

还可以实现多重赋值：

```go
// 交换两个数
x, y = y, x

// 求最大公约数
func gcd(x, y int) int {
    for y != 0 {
        x, y = y, x%y
    }
    return x
} 
```

> PS：对于多重赋值，如果表达式比较复杂，从代码可读性上考虑，应该尽量避免多重赋值，使用多条单个赋值语句。

可以将不需要的赋值赋给 **空标识符** ：

```go
_, err = os.Open(name)
```

## 06 变量的生命周期和作用域

根据作用域的不同，变量可分为 **包级别变量** 和 **局部变量** 。包级别变量可以理解成其他语言的全局变量，但 **Go 语言中没有全局变量的概念** 。

包级别变量声明在包（package）内部，函数体外 ，可以在整个包甚至外部包（被导出后）中被引用；局部变量声明在函数体内、函数参数，以及词法块内（如 if、for），只能在相应的区域中访问。

局部变量和包级别变量可以声明为相同的名称，但使用时遵循就近原则，局部变量会覆盖包级别变量。

```go
package main

import "fmt"

var i int = 10

func main() {
    i := 1
    fmt.Println(i)
}

// 输出 1
```

变量的生命周期指的是程序执行过程中，变量处于 **可访问** 状态的时间段。可访问状态指的是从变量的声明开始，追溯其访问路径，如果路径存在，则表示该变量是可访问的，否则是不可访问的。

```go
var global *int

func f() {
    i := 1
    global = &i
}
```

比如在这个例子中，i 是一个局部变量，照理说出了函数体它就不可访问了，但是由于把 i 的地址赋给了一个指针 global（指针的概念下一节讲解），所以我们仍然可以通过 global 访问到 i，也就是 i 的生命周期还没结束。

（这里留一个小问题：i 是存放在栈上还是堆上？）

生命周期结束的变量，会被 Go 语言的垃圾回收器自动回收（垃圾回收器的内容后面再做讲解）。


## 07 总结

变量使用之前需要声明，对于局部变量来说，声明之后一定要使用，而包级别变量则没有这个限制。

变量的零值机制，短变量，生命周期。