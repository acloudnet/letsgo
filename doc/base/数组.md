数组是具有固定长度，且拥有零个或多个相同数据类型的序列。注意是固定长度。

## 数组的声明和初始化

由于数组要求是固定长度，所以它的声明需要指定长度：

```go
var arr [5]int // 声明 5 个 int 型的元素
```

因为 Go 语言的零值机制，该数组内每个元素都被默认初始化为对应类型的零值。



我们也可以使用 **数组字面量** 来手动初始化数组的元素：

```go
arr := [5]int{1,2,3,4,5}
```



如果不知道数组长度，可以使用 `...` 替代，Go 语言会根据元素的数量来自动推导长度。

```go
arr := [...]int{1,2,3,4}
```

千万不要用 `[]`，这就不是数组了，而是切片（切片的内容后面再讲）。



还有一种初始化方式，使用映射的方式，即索引+值，如：

```go
arr := [5]int{1: 10, 2: 20} // 其余元素保持零值
```

将 `arr[1]、arr[2]` 初始化为 10，20，其余元素保持零值。



## 数组的赋值与比较

只有类型相同的变量才能互相赋值。

在 Go 语言中，数组的类型包括了数组的长度和每个元素的类型。这有这两部分都相同的数组，才是类型相同的数组，才能互相赋值。

```go
var arr1 [5]string
arr2 := [5]string{"hello", "world"}

arr1 = arr2 // yes

arr3 := [4]string{"hello", "world"}
arr1 = arr3 // no
```



## 指针数组和数组指针

Go 语言支持指针，当然就会有指针数组和数组指针。

区别两者，只用看后两个字即可。

- 指针数组：是一个数组，数组里的元素都是指针
- 数组指针：是一个指针，指向一个数组



指针数组和数组指针的声明：

```go
var arr1 [5]*int // 指针数组，数组含5个指向整型的指针
var arr2 *[5]int // 数组指针，一个指针指向含5个整型的数组
```



指针数组和数组指针的初始化：

```go
x, y := 1, 2
arr := [5]int{1: 2, 2: 3}

var p1 *[5]int = &arr  // 数组指针
p2 := [2]*int{&x, &y}  // 指针数组

fmt.Println(*p1[1]) // error
fmt.Println((*p1)[2]) // 3
fmt.Println(*p2[1]) // 2
```

注意，对于数组指针，访问数组元素的时候，不能使用形如 `*p[1]` 这样的方式，因为 `[]` 优先级大于 `*`，`p[n]` 得到元素的值，再使用 `*` 解引用当然就会出错。

必须使用 `(*p)[1]` 这种方式，或者直接 `p[1]` 也是可以的。

而指针数组则不同，指针数组中存的是指针，所以 `p[n]` 得到的是指针，再解引用 `*p[n]` 就得到值。



指针数组的赋值：

```go
arr := [5]*int{0: new(int), 1: new(int)}

*arr[0] = 10
*arr[1] = 20
```

注意，指针的零值是 nil，nil 是不能赋值的，所以，在赋值之前，必须保证指针初始化，这里使用 `new(int)` 初始化为 0。



也可以将一个指针数组赋值给另一个指针数组，同样需要注意必须长度和每个元素的类型都相同，才能赋值。

```go
var arr1 [5]*string
arr2 := [5]*string{new(string), new(string)}

*arr2[0] = "hello"
*arr2[1] = "world"

arr1 = arr2 // yes

var arr3 [2]*string
arr3 = arr2 // no
```



## 在函数间传递数组和指针

在函数间传递数组属于值传递，意味着数组有多大，就需要开辟多大的栈空间来完成复制。

所以，一般是传递指向数组的指针，属于引用传递，只用复制指针大小的数据，要么是 8 字节（64 位系统），要么是 4 字节（32 位系统）。

如下例子传递包含 100万个 int 类型元素的数组，在 64 位系统上，需要 800万字节，即 8MB 内存。

```go
var arr[1e6]int
func foo(arr [1e6]int) {
  ...
}

func foo1(arr [1e6]*int) {
  ...
}

foo(arr) // 传递数组
foo1(&arr) // 传递指针
```

传递数组，每次函数 `foo` 调用时，都要分配 8MB 的内存，非常浪费内存，而传递指针，只用分配 8 字节的内存即可。

但传递指针这种方式，指针指向的内存是共享的，容易引发错误。更好的方式传递方式是切片，下文再详细讲解。

## 多维数组

多维数组都可以由一维数组组成，比如声明一个二维数组：

```go
var [2][4]int
```



使用数组字面量初始化二维数组：

```go
arr := [2][2]int{{1,2}, {3,4}}
```



使用索引+数值的方式初始化：

```go
arr := [4][2]int{0: {1,2}, 3: {3,4}}
```



也可以只初始化单个元素：

```go
arr := [4][2]int{0: {0: 3}, 2: {1: 4}}
```

其余未初始化的都默认初始化为对应类型的零值。



二维数组也可以赋值，同样需要长度和各维数组的元素类型都相同，如下：

```go
var arr1 [2][2]int
var arr2 [2][2]int
var arr3 [1][2]int

arr1[0][0] = 1
arr1[0][1] = 2

arr2 = arr1 // yes
arr3 = arr1 // no

var arr4 [2]int = arr1[1] // 可以赋值一维的数据
```



## 总结

数组的声明、初始化、赋值、使用

指针数组和数组指针，以及指针数组在函数间的传递

多维数组