## 强大的 Go 语言的类型系统

像 C/C++ 语言一样，Go 语言也是一门编译型的语言，这意味着，编译器需要在编译的时候知道程序里每个值的类型，这样编译器才能确保程序能够合理地使用值，有助于减少潜在的代码异常和对代码进行必要的优化。

类型一般需要给编译器提供两个信息：分配多大的内存以及表示什么。比如一个 int64 类型的值，需要给它分配 8 字节的内存，表示一个整数值。

有的类型则与编译代码的机器的体系结构相关，比如一个 int 类型的值，大小可能是 8 字节（64 位机器），也可能是 4 字节（32 位机器）。

在前面的文章中，我们已经见识到了 Go 语言提供的各种类型，包括：

- 基本类型：数值类型（整数、浮点数、复数）、字符类型（字节类型 byte、字符串类型 string）以及布尔类型
- 复合类型：指针类型、容器类型（数组、切片 slice、映射 map）、结构体类型、函数类型、通道类型（chan）、接口类型（interface）

> 可能你还会在别的地方看到诸如原始/非原始类型、内置类型、预声明类型、字面量类型、组合类型、命名/未命名类型，等等多种叫法，这些不过是造了个近义词而已，可以不用管，只要记住上面的两种分法即可。



## Go 支持自定义类型

除了以上基本类型和复合类型之外，Go 语言也支持使用 `type` 关键字自定义类型，这正是 **Go 语言类型系统的强大之处** 。

自定义类型的方法有两种。

第一种，也是最常用的就是使用关键字 `struct`，声明一个结构体类型：

```go
type User struct {
    age int
    name string
}
```

这块的内容，我们在结构体那个小节已经详细讲解过了。



第二种，是基于一个已有的类型，声明一个新类型，这个已有的类型可以是上面所说的“基本类型和复合类型”，是新类型的基础类型。

比如声明一个基于 int 型的新类型 Myint：

```go
type Myint int
var i Myint = 1
j := 1
fmt.Printf("%T\n", i) // main.Myint
fmt.Printf("%T\n", j) // int
```

`i` 的类型是 `main.Myint`。



还有，声明一个基于 slice 类型的新类型 IP：

```go
type IP []byte
var ip IP = IP{'0','1'}
s := []byte{'0', '1'}
fmt.Printf("%T\n", ip) // main.IP
fmt.Printf("%T\n", s)  // []uint8
```



甚至可以在新类型的基础上再声明类型，如：

```go
type A string
type B A
type C B
var (
	a A
    b B
    c C
)
fmt.Printf("%T\n", a) // main.A
fmt.Printf("%T\n", b) // main.A
fmt.Printf("%T\n", c) // main.A
```

上面声明多种类型的情况，也可以简写成：

```go
type (
	A string
    B A
    C B
)
type (
	Age int
    Name string
)
```



## Go 语言不支持隐式类型转换

从上面的例子中可以看出，虽然原类型是新类型的基础类型，但 Go 并不认为它们是同一种类型，正如上面你看到的，`Myint` 是 `main.Myint` 类型，并不是 `int` 类型。



在 Go 语言中，不同类型是不能直接赋值和参与运算的，编译器不会对不同类型的值做隐式转换，但可以使用 `type(a)` 的形式做显示转换。

> 关于类型赋值和类型转换还有一些高阶的内容，这块我们等到后面的文章再来补充。



比如下面的例子：

```go
type A int64
var b int64 = 10
var a A

a = b // cannot use b (type int64) as type A in assignment
fmt.Println(a)
fmt.Println(b * a) // invalid operation: b * a (mismatched types int64 and A)

// 显示转换
a = A(b)
fmt.Println(a) // 10
fmt.Println(a * A(b)) // 100
```

通过显示转换，最终输出正确的结果。



从这里可以看出，Go 语言是一种强类型语言。

强类型语言的好处就是：很多的错误会在编译期间被检查出来，不像 Python 等弱类型语言，很多错误只有运行到才能被发现。

同样，强类型也有一些缺点，写代码的时候要考虑数据类型，这就失去了一定的灵活性。

## 类型声明和类型别名的区别

在数据类型一文中，我们已经见识到了类型别名的用法，它和类型声明的不同就在于使用 `=` 来声明，如：

```go
type INT = int32
```

也可以：

```go
type (
	Age = int32
    Name = string
)
```



既然是类型别名，那么它的类型和原类型就是一致的，这是和类型定义不同的（类型定义新类型和原类型属于不同的类型）

```go
var i INT
var j int32 = 2
i = j
fmt.Printf("%T\n", i) // int32
fmt.Println(i, j, i * j) // 2,2,4
```



## 自定义类型是实现面向对象的基础

Go 语言虽然没有面向对象的完整定义，但面向对象基本所有的特性，包括封装、继承、多态等，它都可以以它独有的方式实现，而这一切实现的基础就是自定义类型。

> 注意，必须是自定义类型，也就是使用 type 关键字定义的类型，而直接操作基础类型存在安全问题，编译器不允许。



比如为自定义类型定义方法，实际上是为类型封装新的行为，类型内嵌又实现了继承，接口类型实现了多态。

（关于这块的详细内容，我们等后面的高阶内容再来详解）

## 总结

Go 语言的基础类型包括基本类型和复合类型

Go 语言支持自定义类型

Go 是强类型语言，不支持隐式类型转换

类型是实现面向对象的基础

注意类型声明和类型别名的区别

类型是实现面向对象的基础

https://juejin.im/post/6844903799501357069

https://segmentfault.com/a/1190000014700528

https://www.tianqiweiqi.com/go-lang-3-1-type-system.html

https://www.jianshu.com/p/ce307b8e9772

